
# This is an example template file that can be processed by using the template
# expansion script "ExpandTemplate.ps1" (a simple template engine).
# In this file, line comments starting with # are used in order to provide 
# some context information.
# The file contains various kinds of placeholders, which can be understood and
# are substituted by the template engine to generate the text file (named as
# the current file, but without the .tmpl extension).
# This template file contain various kinds of placeholders (to substitute 
# environment variables or user-provided variables in form of user variables
# (i.e., key-value pairs), with different kinds of filters applied, or without
# filters).
# To generate the text file from this template, you can use PowerShell code 
# snippets provided by Samples_GenerateFileFromTemplate.ps1, which are related
# to this file. 

# ESCAPING DOUBLE BRACKETS:

{{ Escaped double curly brackets should transform to literal double brackets. }}
{{ {{ This should also works when escaped opening brackets are not matched...
  ... or when escaped closing brackets are not matched. }}

# SIMPLE PLACEHOLDERS:

# Simple placeholders to substitute environment variables:
The value of environment variable ENVSIMPLE is EnvSimpleValue. The path
stored in ENVPATHWIN is:
  C:\Users\Uporabnik\Documents\MyDoc.md
On the other hand, the path stored in ENVPATHUNIX is:
  /home/uporabnik/doc/MyDoc.md

# Output values of all variables used:
Environment variables used in this template:
  ENVPATHWIN:  "C:\Users\Uporabnik\Documents\MyDoc.md"
  ENVPATHUNIX: "/home/uporabnik/doc/MyDoc.md"
  ENVSIMPLE:   "EnvSimpleValue"
  ENVLONGER:   "Value of the environment variable (longer)."
User-provided values (as variables) used in this template:
  MyVarSimple:       "NorthEast"
  MyVarLong:         "This is a longer "str", \ used to demonstrate composed filters.  "
  PathWin:           "C:\Program Files (x86)\Microsoft SQL Server\"
  PathUnix:          "~/doc/MyDoc.md"
  DirtyRelativePath: "../.\.\.//../users//\\/aa/./x.xml"
  DirtyAbsolutePath: "C:\users\\Uporabnik/.//..\Uporabnik/doc/\\/Mydoc.dox"
  EscapedStr:        "sq \' dq \" bsl \\ nl \n cr \r ht \t vt \v bsp \b ff \f null \0 nl \012 A \101 sp \040 ht \x09 Z \x5A ! \x21 weird \x4142 ☺ \u263A ☃ \u2603 π \u03C0 A \u0041 gothicAhsa 𐌰 \U00010330 rocket 🚀 \U0001F680 cat 🐈 \U0001F408"
  EscapedStrSimple:  "sq \' dq \" bsl \\ nl \n cr \r ht \t vt \v bsp \b ff \f null \0 nl \012 A \101 sp \040 ht \x09 Z \x5A ! \x21 weird \x4142 ☺ \u263A ☃ "
  ForUrlEncoding:    "Café Münchën!.#.$.&. .'.(.).*.+.,./.:.;.=.?.@.[.]"
  ForXMLEncoding:    ""Hello & Hoodbye!"  5 < 6 & 7 > 4  <a id=e55>#e55</a>"


# Simple placeholders to substitute user-provided values (via variables):
The user-provided value of MyVarSimple is NorthEast. The quoted value 
of MyVarLong is: "This is a longer "str", \ used to demonstrate composed filters.  "

# PLACEHOLDERS WITH FILTERS to transform values:

# The regq filter replaces " with \" (escapes double quotes).
# Filter regesc filter replaces " with \" and \ with \\ (escapes double quotes
# and backslashes):
var.MyVarLong without filters:
  "This is a longer "str", \ used to demonstrate composed filters.  "
with filter | regq applied:
  "This is a longer \"str\", \ used to demonstrate composed filters.  "
with filter | regesc applied:
  "This is a longer \"str\", \\ used to demonstrate composed filters.  "

# The lower and upper filters change the case:
var.MyVarSimple:
  "NorthEast"
with  filter | lower :
  "northeast"
with  filter | upper :
  "NORTHEAST"

# The trim filter trims the leading and trailing whitespace:
var.MyVarLong without filters:
  "This is a longer "str", \ used to demonstrate composed filters.  "
with filter | trim :
  "This is a longer "str", \ used to demonstrate composed filters."

# The replace filter replaces a substring in the input string:
var.MyVarLong without filters:
  "This is a longer "str", \ used to demonstrate composed filters.  "
with filter | replace:"demonstrate":"show" :
  "This is a longer "str", \ used to show composed filters.  "
with filter | replace:"used to demonstrate":"demonstrating" :
  "This is a longer "str", \ demonstrating composed filters.  "

# The append and prepend filters append or prepend strings:
var.MyVarSimple:
  "NorthEast"
with  filter | append:" or North" :
  "NorthEast or North"
with  filter | prepend:"North-" :
  "North-NorthEast"

# TODO: Not yet implemented: filter arguments not in double quotes
with  filter | prepend:North :
  "{{ var.MyVarSimple | prepend:North }}"

# PATH FILTERS:

# The pathappend filter appends its argument to the path:
var.PathWin without filters:
  "C:\Program Files (x86)\Microsoft SQL Server\"
with filter | pathappend:"myfiles" :
  "C:\Program Files (x86)\Microsoft SQL Server\myfiles"
with filter | pathappend:"dir1\dir2\icon.png" :
  "C:\Program Files (x86)\Microsoft SQL Server\dir1\dir2\icon.png"

var.PathUnix:
  "~/doc/MyDoc.md"
with filter | pathappend:"dir1\dir2\icon.png" :
  "~/doc/MyDoc.mddir1\dir2\icon.png"

# The pathquote filter encloses a path in quotes, if not already enclosed:
env.ENVPATHWIN:
  "C:\Users\Uporabnik\Documents\MyDoc.md"
with filter | pathquote :
  ""C:\Users\Uporabnik\Documents\MyDoc.md""

# The pathwin, pathlinux, pathos, pathwinabs, pathlinuxabs, and pathosabs 
# convert paths to a clean canonical form for specific operating systems.
# Filters with "abs" suffix convert to absolute paths, and filters without
# "abs" suffix leave relative paths in relative form. Filters perform the 
# necessary conversion between slashes '/' and backslashes '\', replace 
# duplicate slashes or backslashes and redundant "/./" parts, resolve "../"
# in absolute paths, and for Linux forms, replace drive parts, e.g. "C:\"
# to "/c/".

var.DirtyRelativePath:
  "../.\.\.//../users//\\/aa/./x.xml"
with filter | pathwin :
  "..\..\users\aa\x.xml"
with filter | pathwinabs :
  "e:\wsorkspace\ws\other\iglibmodules\IGLibScripts\users\aa\x.xml"
with filter | pathlinux :
  "../../users/aa/x.xml"
with filter | pathlinuxabs :
  "/e/wsorkspace/ws/other/iglibmodules/IGLibScripts/users/aa/x.xml"
with filter | pathos :
  "../../users/aa/x.xml"
with filter | pathosabs :
  "/e/wsorkspace/ws/other/iglibmodules/IGLibScripts/users/aa/x.xml"

var.DirtyAbsolutePath:
  "C:\users\\Uporabnik/.//..\Uporabnik/doc/\\/Mydoc.dox"
with filter | pathwin :
  "C:\users\Uporabnik\..\Uporabnik\doc\Mydoc.dox"
with filter | pathwinabs :
  "C:\users\Uporabnik\doc\Mydoc.dox"
with filter | pathlinux :
  "/c/users/Uporabnik/../Uporabnik/doc/Mydoc.dox"
with filter | pathlinuxabs :
  "/c/users/Uporabnik/doc/Mydoc.dox"
with filter | pathos :
  "/c/users/Uporabnik/../Uporabnik/doc/Mydoc.dox"
with filter | pathosabs :
  "/c/users/Uporabnik/doc/Mydoc.dox"

# ENCODING / DECODING, ESCAPING, COMPRESSION filters

# These filters include urlencode / urldecode, xmlencode / xmldecode, 
# base64 / frombase64, hex / fromhex, escc / fromescc, 
# escjava / fromescjava, esccs / fromesccs
# In some cases, input or output can be binary. Where output is binary, 
# filters should be combined with filters that convert binary data to text,
# such as base64 or hex. For example, gzip produced binary result, and can
# be combined with base64 or hex, e.g. "| gzip | base64"; to restore to 
# string, we then use "| frombase64 | gunzip".

# URL encoding / decoding:
var.ForUrlEncoding:
  "Café Münchën!.#.$.&. .'.(.).*.+.,./.:.;.=.?.@.[.]"
with filter | urlencode :
  "Caf%C3%A9%20M%C3%BCnch%C3%ABn!.%23.%24.%26.%20.'.(.).*.%2B.%2C.%2F.%3A.%3B.%3D.%3F.%40.%5B.%5D"
round trip  | urlencode | urldecode :
  "Café Münchën!.#.$.&. .'.(.).*.+.,./.:.;.=.?.@.[.]"

# XML / HTML encoding / decoding:
var.ForXMLEncoding:
  ""Hello & Hoodbye!"  5 < 6 & 7 > 4  <a id=e55>#e55</a>"
with filter | xmlencode :
  "&quot;Hello &amp; Hoodbye!&quot;  5 &lt; 6 &amp; 7 &gt; 4  &lt;a id=e55&gt;#e55&lt;/a&gt;"
round trip  | xmlencode | xmldecode :
  ""Hello & Hoodbye!"  5 < 6 & 7 > 4  <a id=e55>#e55</a>"

# C/C++ -style escaping:
var.EscapedStr:
  "sq \' dq \" bsl \\ nl \n cr \r ht \t vt \v bsp \b ff \f null \0 nl \012 A \101 sp \040 ht \x09 Z \x5A ! \x21 weird \x4142 ☺ \u263A ☃ \u2603 π \u03C0 A \u0041 gothicAhsa 𐌰 \U00010330 rocket 🚀 \U0001F680 cat 🐈 \U0001F408"
with filter | fromescc :
  "sq ' dq " bsl \ nl 
 cr  ht 	 vt  bsp  ff  null   nl 
 A A sp   ht 	 Z Z ! ! weird A42 ☺ u263A ☃ u2603 π u03C0 A u0041 gothicAhsa 𐌰 U00010330 rocket 🚀 U0001F680 cat 🐈 U0001F408"
round trip  | fromescc| escc  :
  "sq \'' dq \"" bsl \\\ nl \n\x0a cr \r\x0d ht \t\x09 vt \x0b bsp \b\x08 ff \f\x0c null \x00 nl \n\x0a A A sp   ht \t\x09 Z Z ! ! weird A42 ☺ u263A ☃ u2603 π u03C0 A u0041 gothicAhsa 𐌰 U00010330 rocket 🚀 U0001F680 cat 🐈 U0001F408"
  "sq \' dq \" bsl \\ nl \n cr \r ht \t vt \v bsp \b ff \f null \0 nl \012 A \101 sp \040 ht \x09 Z \x5A ! \x21 weird \x4142 ☺ \u263A ☃ \u2603 π \u03C0 A \u0041 gothicAhsa 𐌰 \U00010330 rocket 🚀 \U0001F680 cat 🐈 \U0001F408"

# Java -style escaping:
var.EscapedStr:
  "sq \' dq \" bsl \\ nl \n cr \r ht \t vt \v bsp \b ff \f null \0 nl \012 A \101 sp \040 ht \x09 Z \x5A ! \x21 weird \x4142 ☺ \u263A ☃ \u2603 π \u03C0 A \u0041 gothicAhsa 𐌰 \U00010330 rocket 🚀 \U0001F680 cat 🐈 \U0001F408"
with filter | fromescjava :
  "sq ' dq " bsl \ nl 
 cr  ht 	 vt v bsp  ff  null   nl 
 A A sp   ht x09 Z x5A ! x21 weird x4142 ☺ ☺ ☃ ☃ π π A A gothicAhsa 𐌰 0330 rocket 🚀 F680 cat 🐈 F408"
round trip  | fromescjava| escjava  :
  "sq \'' dq \"" bsl \\\ nl \n\u000a cr \r\u000d ht \t\u0009 vt v bsp \b\u0008 ff \f\u000c null \u0000 nl \n\u000a A A sp   ht x09 Z x5A ! x21 weird x4142 \u263a \u263a \u2603 \u2603 \u03c0 \u03c0 A A gothicAhsa \ud800\udf30 \u00010330 rocket \ud83d\ude80 \u0001F680 cat \ud83d\udc08 \u0001F408"
  "sq \' dq \" bsl \\ nl \n cr \r ht \t vt \v bsp \b ff \f null \0 nl \012 A \101 sp \040 ht \x09 Z \x5A ! \x21 weird \x4142 ☺ \u263A ☃ \u2603 π \u03C0 A \u0041 gothicAhsa 𐌰 \U00010330 rocket 🚀 \U0001F680 cat 🐈 \U0001F408"

# C# -style escaping:
var.EscapedStr:
  "sq \' dq \" bsl \\ nl \n cr \r ht \t vt \v bsp \b ff \f null \0 nl \012 A \101 sp \040 ht \x09 Z \x5A ! \x21 weird \x4142 ☺ \u263A ☃ "
with filter | fromesccs :
  "sq ' dq " bsl \ nl 
 cr  ht 	 vt v bsp  ff  null 0 nl 012 A 101 sp 040 ht x09 Z x5A ! x21 weird x4142 ☺ ☺ ☃ "
# ToDo: conversion below throws exception
round trip  | fromesccs| esccs  :
  "{{ var.EscapedStrSimple | fromesccs | esccs }}"
  "sq \' dq \" bsl \\ nl \n cr \r ht \t vt \v bsp \b ff \f null \0 nl \012 A \101 sp \040 ht \x09 Z \x5A ! \x21 weird \x4142 ☺ \u263A ☃ "

# With simpler escaped string:
var.EscapedStr:
  "sq \' dq \" bsl \\ nl \n cr \r ht \t vt \v bsp \b ff \f null \0 nl \012 A \101 sp \040 ht \x09 Z \x5A ! \x21 weird \x4142 ☺ \u263A ☃ \u2603 π \u03C0 A \u0041 gothicAhsa 𐌰 \U00010330 rocket 🚀 \U0001F680 cat 🐈 \U0001F408"
with filter | fromesccs :
  "{{ var.EscapedStr | fromesccs }}"
# ToDo: conversion below throws exception
round trip | fromesccs | esccs  :
  "{{ var.EscapedStr | fromesccs | esccs }}"
  "sq \' dq \" bsl \\ nl \n cr \r ht \t vt \v bsp \b ff \f null \0 nl \012 A \101 sp \040 ht \x09 Z \x5A ! \x21 weird \x4142 ☺ \u263A ☃ \u2603 π \u03C0 A \u0041 gothicAhsa 𐌰 \U00010330 rocket 🚀 \U0001F680 cat 🐈 \U0001F408"


# MULTIPLE FILTERS:

# Multiple filters can be applied to the initial string in order to produce
# the final string with which the placeholder is substituted. Filters are 
# applied from left to right.
var.PathWin without filters:
  "C:\Program Files (x86)\Microsoft SQL Server\"
with filters | pathappend:"dir1\dir2\icon.png" | replace:"\\":"/" :
  "C:/Program Files (x86)/Microsoft SQL Server/dir1/dir2/icon.png"
different order of the same filters can give different results:
with filters | replace:"\\":"/" | pathappend:"dir1\dir2\icon.png" :
  "C:/Program Files (x86)/Microsoft SQL Server/dir1\dir2\icon.png"
more than two filters:
with filters | pathappend:"dir1\dir2\icon.png" | replace:"\\":"/" | prepend:"The path is: " :
  "The path is: C:/Program Files (x86)/Microsoft SQL Server/dir1/dir2/icon.png"

# HANDLING SPACES AND NEWLINES IN PLACEHOLDERS:

# Spaces and newlines within placeholders should not make any difference. 
# This section tests that this is true.

# Spaces in simple placeholders:

Without spaces:
The value of user-defined variable MyVarSimple: "NorthEast"
With space on one side:
The value of user-defined variable MyVarSimple: "NorthEast"
With multiple spaces on both sides: 
The value of user-defined variable MyVarSimple: "NorthEast"
With newline right after open brackets:
The value of user-defined variable MyVarSimple: "NorthEast"
With several newlines:
The value of user-defined variable MyVarSimple: "NorthEast"

# Spaces in placeholders with filters:

var.PathWin without filters:
  "C:\Program Files (x86)\Microsoft SQL Server\"
with three filters, | pathappend:"dir1\dir2\icon.png" | replace:"\\":"/" | prepend:"The path is: " :
  "The path is: C:/Program Files (x86)/Microsoft SQL Server/dir1/dir2/icon.png"
with no spaces:
  "The path is: C:/Program Files (x86)/Microsoft SQL Server/dir1/dir2/icon.png"
with spaces removed even around filter signs ():
  "The path is: C:/Program Files (x86)/Microsoft SQL Server/dir1/dir2/icon.png"
with newline after opening parentheses:
  "The path is: C:/Program Files (x86)/Microsoft SQL Server/dir1/dir2/icon.png"
with newlines after opening and before closing parentheses:
  "The path is: C:/Program Files (x86)/Microsoft SQL Server/dir1/dir2/icon.png"
with newlines also between pipes (at various places):
  "The path is: C:/Program Files (x86)/Microsoft SQL Server/dir1/dir2/icon.png"


# The following environment variables need to be defined for successful
# generation (suggested values are also provided):
#   ENVPATHWIN = C:\Users\Uporabnik\Documents\MyDoc.md
#   ENVPATHUNIX = /home/uporabnik/doc/MyDoc.md
#   ENVSIMPLE = EnvSimpleValue
#   ENVLONGER = Value ot the environment variable (longer)
# The following user-provided variables need to be defined:
#   MyVarSimple = NorthEast
#   MyVarLong = '  This is a longer "str", \ used to demonstrate composed filters.  '
#   PathWin = C:\Program Files (x86)\Microsoft SQL Server\
#   PathUnix = ~/doc/MyDoc.md
#   DirtyRelativePath = "../.\.\.//../users//\\/aa/./x.xml"
#   DirtyAbsolutePath = "C:\users\\Uporabnik/.//..\Uporabnik/doc/\\/Mydoc.dox"
#   EscapedStr = "sq \' dq \`" bsl \\ nl \n cr \r ht \t vt \v bsp \b ff \f null \0 nl \012 A \101 sp \040 ht \x09 Z \x5A ! \x21 weird \x4142 â˜º \u263A â˜ƒ \u2603 Ï€ \u03C0 A \u0041 gothicAhsa ðŒ° \U00010330 rocket ðŸš€ \U0001F680 cat ðŸˆ \U0001F408"
#   EscapedStrSimple = "sq \' dq \`" bsl \\ nl \n cr \r ht \t vt \v bsp \b ff \f null \0 nl \012 A \101 sp \040 ht \x09 Z \x5A ! \x21 weird \x4142 â˜º \u263A â˜ƒ "
#   ForUrlEncoding = "CafÃ© MÃ¼nchÃ«n!.#.$.&. .'.(.).*.+.,./.:.;.=.?.@.[.]"
#   ForXMLEncoding = "`"Hello & Hoodbye!`"  5 < 6 & 7 > 4  <a id=e55>#e55</a>"



