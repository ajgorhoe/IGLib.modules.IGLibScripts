
# This is an example template file that can be processed by using the template
# expansion script "ExpandTemplate.ps1" (a simple template engine).
# In this file, line comments starting with # are used in order to provide 
# some context information.
# The file contains various kinds of placeholders, which can be understood and
# are substituted by the template engine to generate the text file (named as
# the current file, but without the .tmpl extension).
# This template file contain various kinds of placeholders (to substitute 
# environment variables or user-provided variables in form of user variables
# (i.e., key-value pairs), with different kinds of filters applied, or without
# filters).
# To generate the text file from this template, you can use PowerShell code 
# snippets provided by Samples_GenerateFileFromTemplate.ps1, which are related
# to this file. 

# ESCAPING DOUBLE BRACKETS:

\{{ Escaped double curly brackets should transform to literal double brackets. \}}

\{{ \{{ This should also works when escaped opening brackets are not matched...
  ... or when escaped closing brackets are not matched. \}}

\{\{ Escaping with two slashes is also allowed, and it is an intermediate stage
in replacing the usual sequences \{{ and \}}. \}\}

# SIMPLE PLACEHOLDERS:

# Simple placeholders to substitute environment variables:
The value of environment variable ENVSIMPLE is {{ env.ENVSIMPLE }}. The path
stored in ENVPATHWIN is:
  {{ env.ENVPATHWIN }}
On the other hand, the path stored in ENVPATHUNIX is:
  {{ env.ENVPATHUNIX }}

# Output values of all variables used:
Environment variables used in this template:
  ENVPATHWIN:  "{{env.ENVPATHWIN}}"
  ENVPATHUNIX: "{{env.ENVPATHUNIX}}"
  ENVSIMPLE:   "{{env.ENVSIMPLE}}"
  ENVLONGER:   "{{env.ENVLONGER}}"
User-provided values (as variables) used in this template:
  MyVarSimple:       "{{var.MyVarSimple}}"
  MyVarLong:         "{{var.MyVarLong}}"
  PathWin:           "{{var.PathWin}}"
  PathUnix:          "{{var.PathUnix}}"
  DirtyRelativePath: "{{var.DirtyRelativePath}}"
  DirtyAbsolutePath: "{{var.DirtyAbsolutePath}}"
  EscapedStr:        "{{var.EscapedStr}}"
  EscapedStrSimple:  "{{var.EscapedStrSimple}}"
  ForUrlEncoding:    "{{var.ForUrlEncoding}}"
  ForXMLEncoding:    "{{var.ForXMLEncoding}}"


# Simple placeholders to substitute user-provided values (via variables):
The user-provided value of MyVarSimple is {{ var.MyVarSimple }}. The quoted value 
of MyVarLong is: "{{ var.MyVarLong }}"

# PLACEHOLDERS WITH FILTERS to transform values:

# The regq filter replaces " with \" (escapes double quotes).
# Filter regesc filter replaces " with \" and \ with \\ (escapes double quotes
# and backslashes):
var.MyVarLong without filters:
  "{{ var.MyVarLong }}"
with filter | regq applied:
  "{{ var.MyVarLong | regq }}"
with filter | regesc applied:
  "{{ var.MyVarLong | regesc }}"

# The lower and upper filters change the case:
var.MyVarSimple:
  "{{ var.MyVarSimple }}"
with  filter | lower :
  "{{ var.MyVarSimple | lower }}"
with  filter | upper :
  "{{ var.MyVarSimple | upper }}"

# The trim filter trims the leading and trailing whitespace:
var.MyVarLong without filters:
  "{{ var.MyVarLong }}"
with filter | trim :
  "{{ var.MyVarLong | trim }}"

# The replace filter replaces a substring in the input string:
var.MyVarLong without filters:
  "{{ var.MyVarLong }}"
with filter | replace:"demonstrate":"show" :
  "{{ var.MyVarLong | replace:"demonstrate":"show" }}"
with filter | replace:"used to demonstrate":"demonstrating" :
  "{{ var.MyVarLong | replace:"used to demonstrate":"demonstrating" }}"

# The append and prepend filters append or prepend strings:
var.MyVarSimple:
  "{{ var.MyVarSimple }}"
with  filter | append:" or North" :
  "{{ var.MyVarSimple | append:" or North" }}"
with  filter | prepend:"North-" :
  "{{ var.MyVarSimple | prepend:"North-" }}"

# TODO: Not yet implemented: filter arguments not in double quotes
with  filter | prepend:North :
  "\{{ var.MyVarSimple | prepend:North \}}"

# PATH FILTERS:

# The pathappend filter appends its argument to the path:
var.PathWin without filters:
  "{{ var.PathWin }}"
with filter | pathappend:"myfiles" :
  "{{ var.PathWin | pathappend:"myfiles" }}"
with filter | pathappend:"dir1\dir2\icon.png" :
  "{{ var.PathWin | pathappend:"dir1\dir2\icon.png" }}"

var.PathUnix:
  "{{ var.PathUnix }}"
with filter | pathappend:"dir1\dir2\icon.png" :
  "{{ var.PathUnix | pathappend:"dir1\dir2\icon.png" }}"

# The pathquote filter encloses a path in quotes, if not already enclosed:
env.ENVPATHWIN:
  "{{ env.ENVPATHWIN }}"
with filter | pathquote :
  "{{ env.ENVPATHWIN | pathquote }}"

# The pathwin, pathlinux, pathos, pathwinabs, pathlinuxabs, and pathosabs 
# convert paths to a clean canonical form for specific operating systems.
# Filters with "abs" suffix convert to absolute paths, and filters without
# "abs" suffix leave relative paths in relative form. Filters perform the 
# necessary conversion between slashes '/' and backslashes '\', replace 
# duplicate slashes or backslashes and redundant "/./" parts, resolve "../"
# in absolute paths, and for Linux forms, replace drive parts, e.g. "C:\"
# to "/c/".

var.DirtyRelativePath:
  "{{ var.DirtyRelativePath }}"
with filter | pathwin :
  "{{ var.DirtyRelativePath | pathwin }}"
with filter | pathwinabs :
  "{{ var.DirtyRelativePath | pathwinabs }}"
with filter | pathlinux :
  "{{ var.DirtyRelativePath | pathlinux }}"
with filter | pathlinuxabs :
  "{{ var.DirtyRelativePath | pathlinuxabs }}"
with filter | pathos :
  "{{ var.DirtyRelativePath | pathos }}"
with filter | pathosabs :
  "{{ var.DirtyRelativePath | pathosabs }}"

var.DirtyAbsolutePath:
  "{{ var.DirtyAbsolutePath }}"
with filter | pathwin :
  "{{ var.DirtyAbsolutePath | pathwin }}"
with filter | pathwinabs :
  "{{ var.DirtyAbsolutePath | pathwinabs }}"
with filter | pathlinux :
  "{{ var.DirtyAbsolutePath | pathlinux }}"
with filter | pathlinuxabs :
  "{{ var.DirtyAbsolutePath | pathlinuxabs }}"
with filter | pathos :
  "{{ var.DirtyAbsolutePath | pathos }}"
with filter | pathosabs :
  "{{ var.DirtyAbsolutePath | pathosabs }}"

# ENCODING / DECODING, ESCAPING, COMPRESSION filters

# These filters include urlencode / urldecode, xmlencode / xmldecode, 
# base64 / frombase64, hex / fromhex, escc / fromescc, 
# escjava / fromescjava, esccs / fromesccs
# In some cases, input or output can be binary. Where output is binary, 
# filters should be combined with filters that convert binary data to text,
# such as base64 or hex. For example, gzip produced binary result, and can
# be combined with base64 or hex, e.g. "| gzip | base64"; to restore to 
# string, we then use "| frombase64 | gunzip".

# URL encoding / decoding:
var.ForUrlEncoding:
  "{{ var.ForUrlEncoding }}"
with filter | urlencode :
  "{{ var.ForUrlEncoding | urlencode }}"
round trip  | urlencode | urldecode :
  "{{ var.ForUrlEncoding | urlencode | urldecode }}"

# XML / HTML encoding / decoding:
var.ForXMLEncoding:
  "{{ var.ForXMLEncoding }}"
with filter | xmlencode :
  "{{ var.ForXMLEncoding | xmlencode }}"
round trip  | xmlencode | xmldecode :
  "{{ var.ForXMLEncoding | xmlencode | xmldecode }}"

# ESCAPE SEQUENCES IN STRINGS:
# These filters provide conversion from strings with escape sequences in 
# different languages (C/C++, Java, C#) and back from strings to escaped 
# strings.
# WARNING: In some languages, conversion from strings to escaped strings is not
# unique because some characters can be escaped in different ways or not 
# escaped at all (e.g. in C#, due to forms \xH{1,4}, \uHHHH, \UHHHHHHHH).
# Tests usually start from escaped string (due to ease of representation in 
# PowerShell) and compare round-trip-filtered result (e.g. obtained with 
# filters "| fromesccs | esccs") with the initial escaped string. However,
# these strings are not necessarily equal even if all filters work correctly,
# because escaped representations are not unique, and double (round-trip)
# filters can start with one correct representation and end with another.
# To improve detection of errors, we can start with escaped string, applying
# unescaping, and then do the round trip with escaping and another unescaping,
# then compare the first unescaped string with the one obtained by the
# round-trip application of the additional pair of filters. Strings obtained
# in this way should always be equal.

# C/C++ -style escaping:
var.EscapedStr:
  "{{ var.EscapedStr }}"
with filter | fromescc :
  "{{ var.EscapedStr | fromescc }}"
round trip  | fromescc| escc  :
  "{{ var.EscapedStr | fromescc| escc  }}"
  "{{ var.EscapedStr }}"

# These should be the same - fromescc vs. round trip +1:
  | fromescc    vs.
   fromescc | escc | fromescc 
  "{{ var.EscapedStr | fromescc }}"
  "{{ var.EscapedStr | fromescc | escc| fromescc }}"


# Java -style escaping:
var.EscapedStr:
  "{{ var.EscapedStr }}"
with filter | fromescjava :
  "{{ var.EscapedStr | fromescjava }}"
round trip  | fromescjava| escjava  :
  "{{ var.EscapedStr | fromescjava| escjava  }}"
  "{{ var.EscapedStr }}"

# These should be the same - fromescjava vs. round trip +1:
  | fromescjava    vs.
   fromescjava | escjava | fromescjava 
  "{{ var.EscapedStr | fromescjava }}"
  "{{ var.EscapedStr | fromescjava | escjava| fromescjava }}"


# C# -style escaping (simple string):
var.EscapedStrSimple:
  "{{ var.EscapedStrSimple }}"
with filter | fromesccs :
  "{{ var.EscapedStrSimple | fromesccs }}"
round trip  | fromesccs | esccs  (+ original for comparison):
  "{{ var.EscapedStrSimple | fromesccs | esccs }}"
  "{{ var.EscapedStrSimple }}"

# Round trip that starts with an escaped string may not result in
# the initial string due to non-uniquess: in escaped strings, Documents
# characters can be represented in multiple ways.
# But these should be the same - fromesccs vs. round trip +1:
  | fromesccs    vs.
   fromesccs | esccs | fromesccs 
  "{{ var.EscapedStrSimple | fromesccs }}"
  "{{ var.EscapedStrSimple | fromesccs | esccs| fromesccs }}"

# C# -style escaping with more complex string:
var.EscapedStr:
  "{{ var.EscapedStr }}"
with filter | fromesccs :
  "{{ var.EscapedStr | fromesccs }}"
  "{{ var.EscapedStr }}"
round trip | fromesccs | esccs  (+ original for comparison):
  "{{ var.EscapedStr | fromesccs | esccs }}"
  "{{ var.EscapedStr }}"

# These should be the same - fromesccs vs. round trip +1:
  | fromesccs    vs.
   fromesccs | esccs | fromesccs 
  "{{ var.EscapedStr | fromesccs }}"
  "{{ var.EscapedStr | fromesccs | esccs| fromesccs }}"


# Base64 encoding / decoding:
var.EscapedStr:
  "{{ var.EscapedStr }}"
with filter | base64 :
  "{{ var.EscapedStr | base64 }}"
# Round trip conversion to Byte[] (needs additional conversion to string with | utf16)
round trip  | base64 | frombase64  (+ original for comparison):
  "{{ var.EscapedStr | base64 | frombase64 }}"
  "{{ var.EscapedStr }}"

# Round trip conversions back to string:
round trip  | base64 | strfrombase64  (+ original for comparison):
  "{{ var.EscapedStr | base64 | strfrombase64 }}"
  "{{ var.EscapedStr }}"
round trip  | base64 | frombase64 | utf16  (+ original for comparison):
  "{{ var.EscapedStr | base64 | frombase64 | utf16 }}"
  "{{ var.EscapedStr }}"
round trip  | base64 | frombase64:"utf16"  (+ original for comparison):
  "{{ var.EscapedStr | base64 | frombase64:"utf16" }}"
  "{{ var.EscapedStr }}"

# Types of various results:
Type after applying  | base64 :
      {{ var.EscapedStr | base64 | type }}
Type after applying | base64 | frombase64  (problematic before, should be Byte[]):
      {{ var.EscapedStr | base64 | frombase64 | type }}
Type after applying | base64 | frombase64 | utf16 :
      {{ var.EscapedStr | base64 | frombase64 | utf16 | type }}
Type after applying | base64 | frombase64:"utf16" :
      {{ var.EscapedStr | base64 | frombase64:"utf16" | type }}
Type after applying | base64 | strfrombase64 :
      {{ var.EscapedStr | base64 | strfrombase64 | type }}

with filter | base64 | strfrombase64 | base64 :
  "{{ var.EscapedStr | base64 | strfrombase64 | base64  }}"
with filter | base64 | strfrombase64 | base64 :
  "{{ var.EscapedStr | base64 | strfrombase64 | base64 | strfrombase64 }}"

with filter | base64 | frombase64 | utf16 | base64 :
  "{{ var.EscapedStr | base64 | frombase64 | utf16 | base64  }}"
with filter | base64 | frombase64 | utf16 | base64 :
  "{{ var.EscapedStr | base64 | frombase64 | utf16 | base64 | frombase64 | utf16 }}"


# Hexadecimal encoding / decoding:
var.EscapedStr:
  "{{ var.EscapedStr }}"
with filter | hex :
  "{{ var.EscapedStr | hex }}"
# Round trip conversion to Byte[] (needs additional conversion to string with | utf16)
round trip  | hex | fromhex  (+ original for comparison):
  "{{ var.EscapedStr | hex | fromhex  }}"
  "{{ var.EscapedStr }}"

# Round trip conversions back to string:
round trip  | hex | strfromhex  (+ original for comparison):
  "{{ var.EscapedStr | hex | strfromhex }}"
  "{{ var.EscapedStr }}"
round trip  | hex | fromhex | utf16  (+ original for comparison):
  "{{ var.EscapedStr | hex | fromhex | utf16 }}"
  "{{ var.EscapedStr }}"
round trip  | hex | fromhex:"utf16"  (+ original for comparison):
  "{{ var.EscapedStr | hex | fromhex:"utf16" }}"
  "{{ var.EscapedStr }}"

# Types of various results:
Type after applying  | hex :
      {{ var.EscapedStr | hex | type }}
Type after applying | hex | fromhex  (problematic before, should be Byte[]):
      {{ var.EscapedStr | hex | fromhex | type }}
Type after applying | hex | fromhex | utf16 :
      {{ var.EscapedStr | hex | fromhex | utf16 | type }}
Type after applying | hex | fromhex:"utf16" :
      {{ var.EscapedStr | hex | fromhex:"utf16" | type }}
Type after applying | hex | strfromhex :
      {{ var.EscapedStr | hex | strfromhex | type }}

# COMPRESSION / decompression (gzip and gunzip):

# gzip / gunzip of a simple string:
var.PathWin:
  "{{ var.PathWin }}"
with filter | base64 :
  "{{ var.PathWin | base64 | base64 }}"
with filter | gzip | base64 :
  "{{ var.PathWin | gzip | base64 }}"
# Round trip conversion to Byte[] (needs additional conversion to string
# with | utf16)
round trip | gzip | gunzip (+ original for comparison):
  "{{ var.PathWin | gzip | gunzip }}"
  "{{ var.PathWin }}"

# Round trip conversions - zip and back to string:
round trip | gzip | strgunzip  (+ original for comparison):
  "{{ var.PathWin | gzip | strgunzip }}"
  "{{ var.PathWin }}"
round trip | gzip | gunzip | utf16  (+ original for comparison):
  "{{ var.PathWin | gzip | gunzip | utf16 }}"
  "{{ var.PathWin }}"
round trip | gzip | gunzip:"utf16"  (+ original for comparison):
  "{{ var.PathWin | gzip | gunzip:"utf16" }}"
  "{{ var.PathWin }}"

# gzip / gunzip of more complex string (EscapedStr, includes UTF pictographs
# like emojis, even outside the Basic Multilingual Plane)
var.EscapedStr:
  "{{ var.EscapedStr }}"
with filter | base64 :
  "{{ var.EscapedStr | base64 }}"
#with filter | gzip | base64 :
  "{{ var.EscapedStr | gzip | base64 }}"
 Round trip conversion to Byte[] (needs additional conversion to string
# with | utf16)
round trip | gzip | gunzip (+ original for comparison):
  "{{ var.EscapedStr | gzip | gunzip }}"
  "{{ var.EscapedStr }}"

# Round trip conversions - zip and back to string:
round trip | gzip | strgunzip  (+ original for comparison):
  "{{ var.EscapedStr | gzip | strgunzip }}"
  "{{ var.EscapedStr }}"
round trip | gzip | gunzip | utf16  (+ original for comparison):
  "{{ var.EscapedStr | gzip | gunzip | utf16 }}"
  "{{ var.EscapedStr }}"
round trip | gzip | gunzip:"utf16"  (+ original for comparison):
  "{{ var.EscapedStr | gzip | gunzip:"utf16" }}"
  "{{ var.EscapedStr }}"

# The gunzip filter with additional argument "utf8" is NOT implemented
# (and there are currently no plans to implement it), and woulld throw:
round trip | gzip | gunzip:"utf8"  (+ original for comparison):
  "\{{ var.EscapedStr | gzip | gunzip:"utf8" \\}}"
  "\{{ var.EscapedStr \}}"

# MULTIPLE FILTERS:

# Multiple filters can be applied to the initial string in order to produce
# the final string with which the placeholder is substituted. Filters are 
# applied from left to right.
var.PathWin without filters:
  "{{ var.PathWin }}"
with filters | pathappend:"dir1\dir2\icon.png" | replace:"\\":"/" :
  "{{ var.PathWin | pathappend:"dir1\dir2\icon.png" | replace:"\\":"/" }}"
different order of the same filters can give different results:
with filters | replace:"\\":"/" | pathappend:"dir1\dir2\icon.png" :
  "{{ var.PathWin | replace:"\\":"/" | pathappend:"dir1\dir2\icon.png" }}"
more than two filters:
with filters | pathappend:"dir1\dir2\icon.png" | replace:"\\":"/" | prepend:"The path is: " :
  "{{ var.PathWin | pathappend:"dir1\dir2\icon.png" | replace:"\\":"/" | prepend:"The path is: " }}"

# HANDLING SPACES AND NEWLINES IN PLACEHOLDERS:

# Spaces and newlines within placeholders should not make any difference. 
# This section tests that this is true.

# Spaces in simple placeholders:

Without spaces:
The value of user-defined variable MyVarSimple: "{{var.MyVarSimple}}"
With space on one side:
The value of user-defined variable MyVarSimple: "{{ var.MyVarSimple}}"
With multiple spaces on both sides: 
The value of user-defined variable MyVarSimple: "{{  var.MyVarSimple   }}"
With newline right after open brackets:
The value of user-defined variable MyVarSimple: "{{
    var.MyVarSimple   }}"
With several newlines:
The value of user-defined variable MyVarSimple: "{{  
    var.MyVarSimple
    }}"

# Spaces in placeholders with filters:

var.PathWin without filters:
  "{{ var.PathWin }}"
with three filters, | pathappend:"dir1\dir2\icon.png" | replace:"\\":"/" | prepend:"The path is: " :
  "{{ var.PathWin | pathappend:"dir1\dir2\icon.png" | replace:"\\":"/" | prepend:"The path is: " }}"
with no spaces:
  "{{var.PathWin | pathappend:"dir1\dir2\icon.png" | replace:"\\":"/" | prepend:"The path is: "}}"
with spaces removed even around filter signs ():
  "{{var.PathWin|pathappend:"dir1\dir2\icon.png"|replace:"\\":"/"|prepend:"The path is: "}}"
with newline after opening parentheses:
  "{{
      var.PathWin | pathappend:"dir1\dir2\icon.png" | replace:"\\":"/" | prepend:"The path is: " }}"
with newlines after opening and before closing parentheses:
  "{{
      var.PathWin | pathappend:"dir1\dir2\icon.png" | replace:"\\":"/" | prepend:"The path is: "
  }}"
with newlines also between pipes (at various places):
  "{{
      var.PathWin
        | pathappend:"dir1\dir2\icon.png" | 
        replace:"\\":"/"
        |
        prepend:"The path is: "
  }}"


# FILTER ARGUMENTS without quotes:

# Filter arguments that don't contain spaces ' ', colons ':', vertical lines '|', 
# single (') or double quotes (") or closed curly brackets '}', do NOT need to be 
# stated in double quotes.

var.MyVarLong:
  "{{ var.MyVarLong }}"
with filters | replace:demonstrate:show | prepend:** | append:End. : 
  "{{ var.MyVarLong | replace:demonstrate:show | prepend:** | append:End. }}"

var.PathWin:
  "{{ var.PathWin }}"
with filters | pathappend:dir1\dir2\icon.png | replace:\:/ :
  "{{ var.PathWin | pathappend:dir1\dir2\icon.png | replace:\:/ }}"

var.PathWin:
  "{{ var.PathWin }}"
with filters | pathappend:myfiles | prepend:CLEAN :
  {{ var.PathWin | pathappend:myfiles | prepend:CLEAN }}

var.MyVarLong:
  "{{ var.MyVarLong }}"
with filters | escc | replace:longer:sample | fromescc :
  {{ var.MyVarLong | escc | replace:longer:sample | fromescc }}


# Some other examples of DIFFERENT FORMS (filter arguments, etc.):

# Unquoted args:
var.MyVarLong: 
  "{{ var.MyVarLong }}"
var.MyVarLong | replace:demonstrate:show | prepend:* | append:End.  :
  "{{ var.MyVarLong | replace:demonstrate:show | prepend:* | append:End. }}"

# Mixed quoted/unquoted args:
var.PathWin:
  "{{ var.PathWin }}"
var.PathWin | pathappend:"dir1\dir2\icon.png" | replace:\:/  :
  {{ var.PathWin | pathappend:"dir1\dir2\icon.png" | replace:\:/ }}

# Spaces around tokens:
var.MyVarLong:
  "{{ var.MyVarLong }}"
var.MyVarLong    |  lower   | replace  : longer  :  "medium length"  :
  "{{ var.MyVarLong    |  lower   | replace  : longer  :  "medium length" }}"

# Newlines in placeholder - simple:
var.MyVarSimple:
  "{{ var.MyVarSimple }}"
  var.MyVarSimple    
  |  lower  :
  "{{
    var.MyVarSimple    
    |  lower 
  }}"

# Newlines in placeholder - more complex:
var.PathWin:
  "{{ var.PathWin }}"
var.PathWin
  | pathappend:"dir1\dir2\icon.png" | 
  replace:"\\":/
  |
  prepend:"The path is: "  :
  "{{
      var.PathWin
        | pathappend:"dir1\dir2\icon.png" | 
        replace:"\\":/
        |
        prepend:"The path is: "  
  }}"

# Edge case: no filters, just head
var.MyVarSimple:
  "{{ var.MyVarSimple }}"

# Edge case: no spaces; escaped and not escaped backslashes in quoted filter arguments,
# auoted and unquoted arguments:
var.PathWin:
  "{{ var.PathWin }}"
var.PathWin|pathappend:"dir1\\dir2\icon.png"|replace:"\\":/|lower|prepend:"The path is: "|append:.  :
  "{{var.PathWin|pathappend:"dir1\\dir2\icon.png"|replace:"\\":/|lower|prepend:"The path is: "|append:.}}"


# The following environment variables need to be defined for successful
# generation (suggested values are also provided; actual definitions are
# in Samples_GenerateFileFromTemplate.ps1):
#   ENVPATHWIN = C:\Users\Uporabnik\Documents\MyDoc.md
#   ENVPATHUNIX = /home/uporabnik/doc/MyDoc.md
#   ENVSIMPLE = EnvSimpleValue
#   ENVLONGER = Value ot the environment variable (longer)
# The following user-provided variables need to be defined:
#   MyVarSimple = NorthEast
#   MyVarLong = '  This is a longer "str", \ used to demonstrate composed filters.  '
#   PathWin = C:\Program Files (x86)\Microsoft SQL Server\
#   PathUnix = ~/doc/MyDoc.md
#   DirtyRelativePath = "../.\.\.//../users//\\/aa/./x.xml"
#   DirtyAbsolutePath = "C:\users\\Uporabnik/.//..\Uporabnik/doc/\\/Mydoc.dox"
#   EscapedStr = "sq \' dq \`" bsl \\ nl \n cr \r ht \t vt \v bsp \b ff \f null \0 nl \012 A \101 sp \040 ht \x09 Z \x5A ! \x21 weird \x4142 ☺ \u263A ☃ \u2603 π \u03C0 A \u0041 gothicAhsa 𐌰 \U00010330 rocket 🚀 \U0001F680 cat 🐈 \U0001F408"
#   EscapedStrSimple = "sq \' dq \`" bsl \\ nl \n cr \r ht \t vt \v bsp \b ff \f null \0 nl \012 A \101 sp \040 ht \x09 Z \x5A ! \x21 weird \x4142 ☺ \u263A ☃ "
#   ForUrlEncoding = "Café Münchën!.#.$.&. .'.(.).*.+.,./.:.;.=.?.@.[.]"
#   ForXMLEncoding = "`"Hello & Goodbye!`"  5 < 6 & 7 > 4  <a id=e55>#e55</a>"


